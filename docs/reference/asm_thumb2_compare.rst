比对指令
=======================

这些指令对两个参数执行算术或逻辑指令，放弃结果但会设置条件标志。通常，这些指令用于在执行条件分支之前，在不更改数据值的前提下测试数据值。

文件规范
--------------------

符号： ``Rd, Rm, Rn`` 表示ARM寄存器R0-R7。 ``imm8`` 表示一个具有8位宽度的即时值。

应用程序状态寄存器(APSR)
----------------------------------------------

这包含四个由条件分支指令测试的位。通常情况下，条件分支将测试多个位，例如 ``bge(LABEL)`` 。
条件码的含义取决于算术指令的操作数是否被视为有符号或无符号整数。因此， ``bhi(LABEL)`` 假定处理无符号数， ``bgt(LABEL)`` 假定处理有符号数。

APSR位
---------

* Z (zero)

若运算的结果为0或比对的操作数相等，则设置为0。

* N (negative)

若结果为负，则设置为N。

* C (carry)

若结果溢出MSB，则加法设定进位标记，例如把0x80000000和0x80000000相加。由于二进制补码算术的性质，
这种行为在减法时反转，清除借助进位位指示的借位。因此0x10 - 0x01执行为0x10 + 0xffffffff，它将设置进位位。

* V (overflow)

若结果（被视为二进制数的补码）具有与操作数相关的"错误"符号，则会设置溢出标志。例如，将1添加到0x7fffffff将设置溢出位，
因为结果（0x8000000）（被视为二进制补码整数）为负值。请注意：在此情况下，未设置进位位。

比对指令
-----------------------

这些指令会设置APSR（应用程序状态寄存器）、N（负）、Z（零）、C（进位）和V（溢出）标志。

* cmp(Rn, imm8) ``Rn - imm8``
* cmp(Rn, Rm) ``Rn - Rm``
* cmn(Rn, Rm) ``Rn + Rm``
* tst(Rn, Rm) ``Rn & Rm``

条件执行
---------------------

``It`` 和 ``ite`` 指令提供一种有条件地执行一到四个后续指令而无需标记的方法。

* it(<condition>) If then

若<condition>为True，则执行下一指令:

::

    cmp(r0, r1)
    it(eq)
    mov(r0, 100) # runs if r0 == r1
    # execution continues here 此处继续执行

* ite(<condition>) If then else

若<condtion>为真，执行下一指令，否则执行后续指令，因此:

::

    cmp(r0, r1)
    ite(eq)
    mov(r0, 100) # runs if r0 == r1
    mov(r0, 200) # runs if r0 != r1
    # execution continues here 此处继续执行

这可能回扩展为控制至多四条后续指令的执行：it[x[y[z]]] where x,y,z=t/e; e.g. itt, itee, itete, ittte, itttt, iteee, etc.